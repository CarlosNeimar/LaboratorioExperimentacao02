# Scripts/cloneMetric.py

import os
import csv
import subprocess
import shutil
import statistics

# --- Configuração de Caminhos (Adaptado para a sua estrutura) ---
# O script assume que está rodando de dentro da pasta 'Scripts'

# Pega o diretório atual do script (ex: .../LaboratorioExperimentacao02/Scripts)
SCRIPT_DIR = os.path.dirname(__file__)

# Constrói o caminho para os arquivos na pasta 'results'
RESULTS_DIR = os.path.join(SCRIPT_DIR, '..', 'results')

# Arquivo de entrada com a lista de repositórios
INPUT_CSV_PATH = os.path.join(RESULTS_DIR, 'Top1000.csv')

# Arquivo de saída onde as métricas serão salvas
OUTPUT_CSV_PATH = os.path.join(RESULTS_DIR, 'metricas_ck.csv')

# Caminho para o arquivo .jar da ferramenta CK (na mesma pasta do script)
CK_JAR_NAME = 'ck-0.7.1-SNAPSHOT-jar-with-dependencies.jar'
CK_JAR_PATH = os.path.join(SCRIPT_DIR, CK_JAR_NAME)

# Diretórios temporários que serão criados dentro da pasta 'Scripts'
CLONE_DIR = os.path.join(SCRIPT_DIR, "temp_repo")
CK_OUTPUT_DIR = os.path.join(SCRIPT_DIR, "ck_output")


def check_prerequisites():
    """Verifica se os arquivos e comandos necessários existem nos locais esperados."""
    print("Verificando pré-requisitos...")
    if not os.path.exists(INPUT_CSV_PATH):
        print(f"Erro: Arquivo de entrada '{INPUT_CSV_PATH}' não encontrado.")
        return False
    if not os.path.exists(CK_JAR_PATH):
        print(f"Erro: Ferramenta CK '{CK_JAR_PATH}' não encontrada.")
        return False
    if shutil.which("git") is None:
        print("Erro: Comando 'git' não encontrado. Por favor, instale o Git.")
        return False
    if shutil.which("java") is None:
        print("Erro: Comando 'java' não encontrado. Por favor, instale o Java (JDK).")
        return False
    print("Pré-requisitos OK!\n")
    return True


def analyze_repo(repo_url, repo_name):
    """
    Clona um repositório, executa a análise do CK e extrai as métricas.
    Retorna um dicionário com as métricas médias.
    """
    metrics = {
        'cbo_avg': 'error',
        'dit_avg': 'error',
        'lcom_avg': 'error',
        'error_message': 'None'
    }
    
    # Garante que os diretórios temporários não existam antes de começar
    if os.path.exists(CLONE_DIR): shutil.rmtree(CLONE_DIR)
    if os.path.exists(CK_OUTPUT_DIR): shutil.rmtree(CK_OUTPUT_DIR)
    
    try:
        # 1. Clonar o repositório
        print(f"Clonando {repo_name}...")
        subprocess.run(
            ["git", "clone", "--depth", "1", repo_url, CLONE_DIR],
            check=True, capture_output=True, text=True, encoding='utf-8', errors='ignore'
        )

        # 2. Executar a análise do CK
        print(f"Analisando {repo_name} com o CK...")
        os.makedirs(CK_OUTPUT_DIR) # Cria o diretório de saída para o CK
        
        ck_command = [
            "java", "-jar", CK_JAR_PATH,
            CLONE_DIR, "false", "0", "false", CK_OUTPUT_DIR
        ]
        subprocess.run(ck_command, check=True, capture_output=True, text=True, encoding='utf-8', errors='ignore')

        # 3. Ler o resultado e calcular as métricas médias
        class_metrics_file = os.path.join(CK_OUTPUT_DIR, "class.csv")
        
        if os.path.exists(class_metrics_file):
            cbo_values, dit_values, lcom_values = [], [], []
            with open(class_metrics_file, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    cbo_values.append(int(row['cbo']))
                    dit_values.append(int(row['dit']))
                    lcom_values.append(float(row['lcom']))

            if cbo_values:
                metrics['cbo_avg'] = round(statistics.mean(cbo_values), 2)
                metrics['dit_avg'] = round(statistics.mean(dit_values), 2)
                metrics['lcom_avg'] = round(statistics.mean(lcom_values), 2)
                metrics['error_message'] = 'Success'
            else:
                metrics['error_message'] = 'No classes found by CK'
        else:
            metrics['error_message'] = 'class.csv not generated by CK'
            
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr.strip().split('\n')[-1]
        print(f"  -> Erro no processo para o repositório {repo_name}: {error_msg}")
        metrics['error_message'] = error_msg
    except Exception as e:
        print(f"  -> Ocorreu um erro inesperado para o repositório {repo_name}: {e}")
        metrics['error_message'] = str(e)
    finally:
        # 4. Limpar: excluir os diretórios temporários
        if os.path.exists(CLONE_DIR):
            shutil.rmtree(CLONE_DIR)
        if os.path.exists(CK_OUTPUT_DIR):
            shutil.rmtree(CK_OUTPUT_DIR)
    
    return metrics


def main():
    """Função principal que orquestra todo o processo."""
    if not check_prerequisites():
        return

    try:
        with open(INPUT_CSV_PATH, 'r', encoding='utf-8') as f:
            repos_to_analyze = list(csv.DictReader(f))
    except FileNotFoundError:
        print(f"Erro: Arquivo de entrada '{INPUT_CSV_PATH}' não encontrado.")
        return

    while True:
        try:
            num_to_clone = int(input(f"Quantos repositórios você quer analisar (de 1 a {len(repos_to_analyze)})? "))
            if 1 <= num_to_clone <= len(repos_to_analyze):
                break
            else:
                print("Por favor, insira um número dentro do intervalo válido.")
        except ValueError:
            print("Entrada inválida. Por favor, insira um número.")
    
    all_results = []
    
    for i in range(num_to_clone):
        repo_info = repos_to_analyze[i]
        repo_name = repo_info['full_name']
        repo_url = repo_info['url']
        
        print("-" * 50)
        print(f"Processando repositório {i+1}/{num_to_clone}: {repo_name}")
        
        analysis_result = analyze_repo(repo_url, repo_name)
        
        final_result = {
            'rank': repo_info['rank'],
            'full_name': repo_name,
            'stars': repo_info['stars'],
            'url': repo_url,
            **analysis_result
        }
        all_results.append(final_result)
        print(f"  -> Resultados para {repo_name}: {analysis_result}")

    if all_results:
        print("-" * 50)
        print(f"Análise concluída. Salvando resultados em '{OUTPUT_CSV_PATH}'...")
        with open(OUTPUT_CSV_PATH, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=all_results[0].keys())
            writer.writeheader()
            writer.writerows(all_results)
        print("Arquivo salvo com sucesso!")
    else:
        print("Nenhum repositório foi analisado.")


if __name__ == "__main__":
    main()