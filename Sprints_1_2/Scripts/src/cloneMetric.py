import os
import csv
import subprocess
import shutil
import statistics

SCRIPT_DIR = os.path.dirname(__file__)
RESULTS_DIR = os.path.join(SCRIPT_DIR, '../..', 'results')
INPUT_CSV_PATH = os.path.join(RESULTS_DIR, 'Top1000.csv')
OUTPUT_CSV_PATH = os.path.join(RESULTS_DIR, 'metricas_ck.csv')
CK_JAR_NAME = 'ck-0.7.1-SNAPSHOT-jar-with-dependencies.jar'
CK_JAR_PATH = os.path.join(SCRIPT_DIR, '..', CK_JAR_NAME)
CLONE_DIR = os.path.join(SCRIPT_DIR, "temp_repo")
CK_OUTPUT_DIR = os.path.join(SCRIPT_DIR, "ck_output")

def check_prerequisites():
    """Verifica se os arquivos e comandos necessários existem nos locais esperados."""
    print("Verificando pré-requisitos...")
    if not os.path.exists(INPUT_CSV_PATH):
        print(f"Erro: Arquivo de entrada '{INPUT_CSV_PATH}' não encontrado.")
        return False
    if not os.path.exists(CK_JAR_PATH):
        print(f"Erro: Ferramenta CK '{CK_JAR_PATH}' não encontrada.")
        return False
    if shutil.which("git") is None:
        print("Erro: Comando 'git' não encontrado. Por favor, instale o Git.")
        return False
    if shutil.which("java") is None:
        print("Erro: Comando 'java' não encontrado. Por favor, instale o Java (JDK).")
        return False
    print("Pré-requisitos OK!\n")
    return True


def analyze_repo(repo_url, repo_name):
    """
    Clona um repositório, encontra o diretório de código-fonte Java,
    executa a análise do CK e extrai as métricas.
    Retorna um dicionário com as métricas médias.
    """
    metrics = {
        'cbo_avg': 'error',
        'dit_avg': 'error',
        'lcom_avg': 'error',
        'error_message': 'None'
    }
    
    if os.path.exists(CLONE_DIR): shutil.rmtree(CLONE_DIR)
    if os.path.exists(CK_OUTPUT_DIR): shutil.rmtree(CK_OUTPUT_DIR)

    try:
        print(f"Clonando {repo_name}...")
        subprocess.run(
            ["git", "clone", "--depth", "1", repo_url, CLONE_DIR],
            check=True, capture_output=True, text=True, encoding='utf-8', errors='ignore'
        )

        print(f"  -> Tentando compilar {repo_name} com Maven (isso pode demorar)...")
        subprocess.run(
            ["mvn", "clean", "package", "-DskipTests"],
            check=True, capture_output=True, text=True, encoding='utf-8', errors='ignore',
            cwd=CLONE_DIR 
        )
        print(f"  -> Compilação bem-sucedida (ou ignorada).")

        java_source_dir = CLONE_DIR 
        
        print("  -> Buscando por um diretório de código-fonte padrão ('src/main/java')...")
        for root, dirs, files in os.walk(CLONE_DIR):
            if root.endswith(os.path.join('src', 'main', 'java')):
                java_source_dir = root
                print(f"  -> Diretório de módulo Java encontrado: {java_source_dir}")
                break 
        
        if java_source_dir == CLONE_DIR:
             print("  -> Aviso: Nenhum diretório 'src/main/java' encontrado. O CK analisará a raiz do projeto.")

        # 3. Executar a análise do CK
        print(f"Analisando o diretório '{java_source_dir}' com o CK...")
        os.makedirs(CK_OUTPUT_DIR)
        
        ck_command = [
            "java", "-jar", CK_JAR_PATH,
            java_source_dir,
            "false", 
            "0", 
            "false", 
            CK_OUTPUT_DIR
        ]
        subprocess.run(ck_command, check=True, capture_output=True, text=True, encoding='utf-8', errors='ignore')

        class_metrics_file = os.path.join(CK_OUTPUT_DIR, "class.csv")
        
        if os.path.exists(class_metrics_file):
            cbo_values, dit_values, lcom_values = [], [], []
            with open(class_metrics_file, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                rows = list(reader)
                if not rows:
                     metrics['error_message'] = 'CK ran but found no classes'
                else:
                    for row in rows:
                        cbo_values.append(int(row['cbo']))
                        dit_values.append(int(row['dit']))
                        lcom_values.append(float(row['lcom']))

                    metrics['cbo_avg'] = round(statistics.mean(cbo_values), 2)
                    metrics['dit_avg'] = round(statistics.mean(dit_values), 2)
                    metrics['lcom_avg'] = round(statistics.mean(lcom_values), 2)
                    metrics['error_message'] = 'Success'
        else:
            metrics['error_message'] = 'class.csv not generated by CK'
            
    except subprocess.CalledProcessError as e:
        error_msg = e.stderr.strip()
        print(f"  -> ERRO: A ferramenta CK falhou para o repositório {repo_name}.")
        metrics['error_message'] = error_msg if error_msg else "CK failed with no error message"
    except Exception as e:
        print(f"  -> ERRO INESPERADO para o repositório {repo_name}: {e}")
        metrics['error_message'] = str(e)
    finally:
        if os.path.exists(CLONE_DIR):
            shutil.rmtree(CLONE_DIR)
        if os.path.exists(CK_OUTPUT_DIR):
            shutil.rmtree(CK_OUTPUT_DIR)
    return metrics

def main():
    """Função principal que orquestra todo o processo."""
    if not check_prerequisites():
        return

    try:
        with open(INPUT_CSV_PATH, 'r', encoding='utf-8') as f:
            repos_to_analyze = [row for row in csv.DictReader(f) if row]
    except FileNotFoundError:
        print(f"Erro: Arquivo de entrada '{INPUT_CSV_PATH}' não encontrado.")
        return

    while True:
        try:
            num_to_clone = int(input(f"Quantos repositórios você quer analisar (de 1 a {len(repos_to_analyze)})? "))
            if 1 <= num_to_clone <= len(repos_to_analyze):
                break
            else:
                print("Por favor, insira um número dentro do intervalo válido.")
        except ValueError:
            print("Entrada inválida. Por favor, insira um número.")
    
    all_results = []
    
    for i in range(num_to_clone):
        repo_info = repos_to_analyze[i]
        repo_name = repo_info['full_name']
        repo_url = repo_info['url']
        
        print("-" * 50)
        print(f"Processando repositório {i+1}/{num_to_clone}: {repo_name}")
        
        analysis_result = analyze_repo(repo_url, repo_name)
        
        final_result = {
            'rank': repo_info['rank'],
            'full_name': repo_name,
            'stars': repo_info['stars'],
            'url': repo_url,
            **analysis_result
        }
        all_results.append(final_result)
        print(f"  -> Resultados para {repo_name}: {analysis_result}")

    # Salva todos os resultados no arquivo de saída.
    if all_results:
        print("-" * 50)
        print(f"Análise concluída. Salvando resultados em '{OUTPUT_CSV_PATH}'...")
        with open(OUTPUT_CSV_PATH, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=all_results[0].keys())
            writer.writeheader()
            writer.writerows(all_results)
        print("Arquivo salvo com sucesso!")
    else:
        print("Nenhum repositório foi analisado.")


if __name__ == "__main__":
    main()